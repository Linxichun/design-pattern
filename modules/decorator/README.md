# 简介
## 为什么要使用装饰模式
先问个问题，有什么方法可以给一个类增加方法？ 
一般有两种方式：
- 继承。继承一个父类。
- 关联。在这个类中嵌入另一个类的对象。

哪种方法好呢？ 
关联方式好。因为第一种方式把父类所有的方法都继承了，较为臃肿，而且也不能再继承其他类了。而第二种方法可以有
这个类来决定调用另一个类的什么方法，较为灵活。第二种方法就是装饰模式的思想。
## 什么是装饰模式
装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。
## 别名
包装器Wrapper模式。
## 类型
对象结构型模式。
## 遵守的原则
开闭原则。客户端可以根据具体需要添加具体构建类和具体装饰类，并进行组合。
# 本文角色
- Component，抽象构件 
    - 抽象类
    - 具体构件和抽象装饰类的共同父类。
    - 声明了在具体构件中实现的业务方法。
    - 使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。
- ConcreteComponent，具体构件 
    - 具体类
    - 抽象构件的子类。
    - 实现了在抽象构件中声明的方法，装饰器可以给它增加额外的方法。
- Decorator，抽象装饰类 
    - 抽象类
    - 抽象构件的子类。
    - 用于给具体构件增加职责。
    - 具体职责在其子类中实现。
- ConcreteDecorator，具体装饰类 
    - 具体类
    - 抽象装饰类的子类。
    - 负责向构件添加新的职责。
    - 每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。
# 实现
- 创建抽象构件Component.java
- 创建具体构件ConcreteComponent.java
- 创建抽象装饰类Decorator.java
- 创建抽象装饰类Decorator.java
- 创建客户端类Client.java
# 优缺点
## 优点
- 灵活。装饰模式和继承都可以扩展类的方法，但相比继承，装饰模式的灵活性更高。
- 符合“开闭原则”。客户端可以根据具体需要添加具体构建类和具体装饰类，并进行组合。
## 缺点
- 复杂，易出错。装饰模式和继承都可以扩展类的方法，但相比继承，装饰模式的设计更为复杂，也更容易出错。
# 适用环境
- 当不能使用继承或者不适合使用继承时，采用装饰模式。
## 使用场景
- 待补充
# 扩展
## 相关模式
- 适配器模式Adapter：装饰模式Decorator不同于适配器Adapter模式，因为装饰仅改变对象的职责而不改变接口，适配器将给对象一个全新的接口。
- 组合模式Composite：可以将装饰视为一个仅有一个组件的组合。
- 策略模式Strategy模式：装饰模式改变对象的外表，策略模式改变对象的内在。
# 问题
## 在软件设计中，你是在哪里见到或用到了装饰模式？怎么用的
Java I/O中的FilterInputStream、FilterOutputStream、BufferedInputStream、DataInputStream等类中使用了装饰模式。
详情请参考 [Java8 I/O源码-FilterInputStream、FilterOutputStream与装饰器模式](http://blog.csdn.net/panweiwei1994/article/details/78230611)

