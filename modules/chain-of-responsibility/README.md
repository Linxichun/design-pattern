# 简介
## 为什么要使用责任链模式
在软件系统中，有能力处理客户端请求的对象可能不止一个。客户端发送请求后，怎么安排对象处理请求是个问题。职责
链模式可以将这些请求的处理者组织成一条链，请求沿着这条链传递，直到有对象可以处理它为止。客户端无需关系处理
的细节以及请求的传递，只需要将请求发送到链上即可。
## 什么是责任链模式
职责链模式(Chain of Responsibility Pattern)：使多个对象都有机会处理请求，从而避免请求发送者与接收者耦合在一起。
将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。
## 类型
对象行为型模式
## 遵守的原则
迪米特法则、开闭原则
> 迪米特法则
  定义：一个对象应该对其他对象保持最少的了解。
  问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。
  解决方案：尽量降低类与类之间的耦合。
# 本文角色
- Handler：抽象处理者 
    - 一般是抽象类。定义了处理请求的接口。
    - 定义了请求处理抽象方法handleRequest()，规范了子类处理请求的操作。
    - 为了将处理者组成一条链，抽象处理者需要返回一个本处理者的下个处理者的引用。由于处理者的下方还是处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor），作为下个处理者的引用（可选）。
- ConcreteHandler：具体处理者 
    - 继承Handler的具体处理者角色。
    - 实现了handleRequest()抽象方法来处理请求。
    - 具体处理者接到请求后，如果可以处理就将请求处理掉；否则通过对下个处理者的引用将请求转发给下个处理者。
- Client 
    - 客户。向链上提交清求。
# 扩展
## 纯职责链
- 每个处理者接收到请求后，要么单纯转发请求，要么单纯处理请求。不允许既处理请求，又转发请求的情况。
- 请求必须被责任链上的某个处理者处理。不允许出现请求未被处理的情况
## 不纯职责链
- 每个处理者接收到请求后，除了单纯转发请求，或者单纯处理请求，还可以 
    - 部分处理请求后，转发
    - 完全处理请求后，转发给下个处理者
- 请求可以不被责任链上的任何处理者处理。
# 优缺点
## 优点
- 遵守“迪米特法则”。请求发送者只负责创建链，不需要知道请求被哪个处理者处理，怎样处理。
- 遵守“开闭原则”，新增了一个处理者，只需要在客户端中重新建立链即可，原有系统不需要修改。
- 增强了灵活性。可以在运行时刻对职责链进行动态的增加或者修改。
## 缺点
- 请求不一定会被处理。无论是没有可以处理请求的接受者，还是责任链创建错误，都有可能导致请求不被处理。
- 可能造成死循环。责任链如果是环状的，可能会导致循环调用，造成死循环。
# 适用环境
- 有多个对象可以处理一个请求，但只能等运行时才能确定哪个对象处理。
- 想在不明确指定接受者的情况下，向多个对象中的一个提交请求。
- 可处理一个请求的对象集合应被动态指定。
## 使用场景
- Servlet中的过滤器Filter
## 责任链模式和组合模式的联系
责任链模式常和组合模式一起使用。在这种情况下，一个构件的副构件可作为它的后继。
# 问题
## 在软件开发中，你在哪里用到了责任链模式？怎么用的？
待补充。